# 注意する挙動
* keyword 引数の評価のタイミング

```python
>>> def foo():
...     print("foo")
...
>>> def bar(x=foo()):
...     pass
...
foo # bar 関数の定義時に 1 回だけ評価される
>>> bar() # bar 関数の呼び出し時には評価されない
```

* def 文ではあまり見かけないが、lambda 式で問題が発生しているのを見かけることがあります。

```python
>>> f = [lambda x: x * i for i in range(5)]  # x * 0, x * 1, x * 2, ... という関数のリストにしたかったコード
>>> f[2](5) # 5 * 2 = 10 を期待したが、呼び出した時には i はすでに 4 になっていて 5 * 4 = 20
20
>>> f[3](5)
20
>>> f = [lambda x, i=i: x * i for i in range(5)]
>>> f[2](5) # keyword 引数に渡すと定義時に評価される
10
>>> f[3](5)
15
```

* 代入によってローカル変数が作られます。

```python
>>> def outer1():
...     x = 1
...     def inner1():
...         print(x) # outer1() 関数内で有効な変数 x
...     inner1()
...     print(x)
...
>>> outer1()
1 # inner1
1 # outer1
>>> def outer2():
...     x = 1
...     def inner2():
...         x = 2  # inner2() 関数内で有効な変数 x を作成 (変数の有効な範囲をスコープと呼びます)
...         print(x)
...     inner2()
...     print(x)  # outer2() 関数で有効な変数 x は上書きされない
...
>>> outer2()
2 # inner2
1 # outer2
```

* 変数はすべて参照

```python
>>> a = list(range(5))
>>> a
[0, 1, 2, 3, 4]
>>> b = a
>>> b
[0, 1, 2, 3, 4]
>>> b[0] = 5  # b の 0 番目を変えたつもりが...
>>> b
[5, 1, 2, 3, 4]
>>> a  # a の 0 番目も変わってしまう
[5, 1, 2, 3, 4]
>>> id(a)  # id() 関数はオブジェクトの ID (アドレス) を返すので、比較することで同一オブジェクトを参照しているか確認が可能
4509821312
>>> id(b)  # a の ID と一致しているので a と b は同一オブジェクトを参照している
4509821312
```

* リストや文字列のスライスはコピーを生成
  * スライスはリスト等に対して、`[開始:終了]` で取得したもので、リストの一部を取り出すのに使用します。

```python
>>> a = list(range(5))
>>> a
[0, 1, 2, 3, 4]
>>> b = a[:]  # 省略した場合は [0:-1] と同じで最初から最後までを指定します
>>> b
[0, 1, 2, 3, 4]
>>> b[0] = 5
>>> b
[5, 1, 2, 3, 4]
>>> a
[0, 1, 2, 3, 4]
>>> id(a)  # スライスの場合 a と b の ID が異なることが確認できます
4509821376
>>> id(b)
4509820416
```